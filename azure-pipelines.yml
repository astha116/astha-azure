# Azure DevOps Pipeline for Node.js App to AKS
trigger:
  branches:
    include:
    - main
  paths:
    include:
    - src/*
    - Dockerfile
    - Manifest-files/*
    - azure-pipelines.yml

# Variables

variables:
- group: keyvault-secrets   

- name: dockerRegistryServiceConnection 
  value: my-docker-conn

- name: imageRepository
  value: nodejs-app

- name: containerRegistry
  value: asthaazureregistry.azurecr.io

- name: dockerfilePath
  value: $(Build.SourcesDirectory)/Dockerfile

- name: tag
  value: $(Build.BuildId)

- name: kubernetesServiceConnection
  value: my-aks-conn

- name: kubernetesNamespace
  value: default

- name: vmImageName
  value: ubuntu-latest

- name: sonarQubeUrl
  value: 'https://sonarcloud.io'

- name: sonarQubeProjectKey
  value: 'asthajain1160521_astha-azure'

- name: sonarQubeProjectName
  value: 'astha-azure'


stages:
- stage: Build
  displayName: Build and Push Image
  jobs:
  - job: Build
    displayName: Build
    pool:
      name: Default
      vmImage: $(vmImageName)
    steps:
    - task: NodeTool@0
      displayName: 'Install Node.js'
      inputs:
        versionSpec: '18.x'
    
    - script: |
        cd src
        npm install
        npm run test
      displayName: 'Install dependencies and run tests'

    # 2) Download & install SonarScanner CLI **for Windows**
    - powershell: |
        $ErrorActionPreference = 'Stop'
        $ver  = '5.0.1.3006'
        $zip  = "sonar-scanner-cli-$ver-windows.zip"
        Write-Host "Downloading $zip ..."
        Invoke-WebRequest -Uri "https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/$zip" -OutFile $zip

        Write-Host "Extracting ..."
        Expand-Archive -Path $zip -DestinationPath .

        # Add scanner\bin to PATH for this session
        $scannerDir = (Get-ChildItem sonar-scanner-* -Directory)[0].FullName
        $env:PATH   = "$scannerDir\bin;$env:PATH"

        # Quick check
        sonar-scanner.bat -v
      displayName: 'Install SonarScanner CLI (Windows)'

    # 3) Run the analysis â€“ pass the token via env-var so it is masked
    - powershell: |
        $scannerDir = (Get-ChildItem sonar-scanner-* -Directory).FullName
        $env:PATH   = "$scannerDir\bin;$env:PATH"

        sonar-scanner.bat `
          -D"sonar.projectKey=$(sonarQubeProjectKey)" `
          -D"sonar.projectName=$(sonarQubeProjectName)" `
          -D"sonar.projectVersion=$(Build.BuildNumber)" `
          -D"sonar.sources=src" `
          -D"sonar.exclusions=**\node_modules\**" `
          -D"sonar.host.url=$(sonarQubeUrl)" `
          -D"sonar.organization=asthajain1160521" `
          -D"sonar.login=$env:SONAR_TOKEN"
      displayName: 'Run SonarQube analysis'
      env:
        SONAR_TOKEN: $(azure-sonarqube)
    - task: Docker@2
      displayName: Build and push image to container registry
      inputs:
        command: buildAndPush
        repository: $(imageRepository)
        dockerfile: $(dockerfilePath)
        containerRegistry: $(dockerRegistryServiceConnection)
        tags: |
          $(tag)
          latest
      condition: and(succeeded(), or(eq(variables['Build.SourceBranch'], 'refs/heads/main'), eq(variables['Build.SourceBranch'], 'refs/heads/dev')))
    
    - task: PublishPipelineArtifact@1
      displayName: 'Publish Kubernetes manifests'
      inputs:
        artifactName: 'manifests'
        path: '$(Build.SourcesDirectory)/Manifest-files/'

- stage: DeployDev
  displayName: Deploy to Dev with Helm
  dependsOn: Build
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  - deployment: DeployDev
    displayName: Deploy to Dev via Helm
    pool:
      name: Default
      vmImage: $(vmImageName)
    environment: 'dev'
    variables:
    - name: targetNamespace
      value: 'dev'
    strategy:
      runOnce:
        deploy:
          steps:
          - task: DownloadPipelineArtifact@2
            displayName: 'Download Helm Chart'
            inputs:
              artifactName: 'manifests'
              downloadPath: '$(System.ArtifactsDirectory)'
          - task: HelmInstaller@1
            displayName: 'Install Helm'
            inputs:
              helmVersionToInstall: 'latest'
          # Create Dev Namespace (Automatic)
          # - task: Kubernetes@1
          #   displayName: 'Create Dev Namespace'
          #   inputs:
          #     connectionType: 'Kubernetes Service Connection'
          #     kubernetesServiceEndpoint: $(kubernetesServiceConnection)
          #     command: 'apply'
          #     arguments: '-f -'
          #     inline: |
          #       apiVersion: v1
          #       kind: Namespace
          #       metadata:
          #         name: $(targetNamespace)
          #         labels:
          #           environment: development
            # continueOnError: true
          - script: |
              echo "Creating namespace: $(targetNamespace)"
              kubectl create namespace $(targetNamespace) --dry-run=client -o yaml | kubectl apply -f -
              kubectl label namespace $(targetNamespace) environment=development --overwrite
              echo "Namespace $(targetNamespace) ready"
            displayName: 'Ensure Dev Namespace Exists'
            continueOnError: true

          - task: HelmDeploy@0
            displayName: 'Helm upgrade/install release'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceConnection: $(kubernetesServiceConnection)
              namespace: $(targetNamespace)
              command: upgrade
              chartType: FilePath
              chartPath: '$(System.ArtifactsDirectory)/manifests'
              releaseName: 'nodejs-app-dev'
              valueFile: '$(System.ArtifactsDirectory)/manifests/values-dev.yaml'
              overrideValues: |
                image.repository=$(containerRegistry)/$(imageRepository)
                image.tag=$(tag)
              install: true
              waitForExecution: true
- stage: DeployTest
  displayName: Deploy to Test with Helm
  dependsOn: Build
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  - deployment: DeployTest
    displayName: Deploy to Test via Helm
    pool:
      name: Default
      vmImage: $(vmImageName)
    environment: 'test'
    variables:
    - name: targetNamespace
      value: 'test'
    strategy:
      runOnce:
        deploy:
          steps:
          - task: DownloadPipelineArtifact@2
            displayName: 'Download Helm Chart'
            inputs:
              artifactName: 'Manifest-files'
              downloadPath: '$(System.ArtifactsDirectory)'
          - task: HelmInstaller@1
            displayName: 'Install Helm'
            inputs:
              helmVersionToInstall: 'latest'
          # Create Test Namespace (Automatic)
          - task: Kubernetes@1
            displayName: 'Create Test Namespace'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceEndpoint: $(kubernetesServiceConnection)
              command: 'apply'
              arguments: '-f -'
              inline: |
                apiVersion: v1
                kind: Namespace
                metadata:
                  name: $(targetNamespace)
                  labels:
                    environment: test
            continueOnError: true

          - task: HelmDeploy@0
            displayName: 'Helm upgrade/install release'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceConnection: $(kubernetesServiceConnection)
              namespace: $(kubernetesNamespace)
              command: upgrade
              chartType: FilePath
              chartPath: '$(Build.SourcesDirectory)/Manifest-files'
              releaseName: 'nodejs-app-test'
              valueFile: '$(System.ArtifactsDirectory)/Manifest-files/values-test.yaml'
              overrideValues: |
                image.repository=$(containerRegistry)/$(imageRepository)
                image.tag=$(tag)
              install: true
              waitForExecution: true

- stage: DeployProd
  displayName: Deploy to Prod with Helm
  dependsOn: Build
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  - deployment: DeployProd
    displayName: Deploy to Prod via Helm
    pool:
      name: Default
      vmImage: $(vmImageName)
    environment: 'prod'
    variables:
    - name: targetNamespace
      value: 'prod'
    strategy:
      runOnce:
        deploy:
          steps:
          - task: DownloadPipelineArtifact@2
            displayName: 'Download Helm Chart'
            inputs:
              artifactName: 'Manifest-files'
              downloadPath: '$(System.ArtifactsDirectory)'
          - task: HelmInstaller@1
            displayName: 'Install Helm'
            inputs:
              helmVersionToInstall: 'latest'
          # Create Prod Namespace (Automatic)
          - task: Kubernetes@1
            displayName: 'Create Prod Namespace'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceEndpoint: $(kubernetesServiceConnection)
              command: 'apply'
              arguments: '-f -'
              inline: |
                apiVersion: v1
                kind: Namespace
                metadata:
                  name: $(targetNamespace)
                  labels:
                    environment: production
            continueOnError: true

          - task: HelmDeploy@0
            displayName: 'Helm upgrade/install release'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceConnection: $(kubernetesServiceConnection)
              namespace: $(kubernetesNamespace)
              command: upgrade
              chartType: FilePath
              chartPath: '$(Build.SourcesDirectory)/Manifest-files'
              releaseName: 'nodejs-app-prod'
              valueFile: '$(System.ArtifactsDirectory)/Manifest-files/values-prod.yaml'
              overrideValues: |
                image.repository=$(containerRegistry)/$(imageRepository)
                image.tag=$(tag)
              install: true
              waitForExecution: true
